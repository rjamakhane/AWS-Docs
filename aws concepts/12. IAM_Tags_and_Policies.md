# 🏷️ AWS IAM Tags and Policies – Deep Dive Notes

> **File:** IAM_Tags_and_Policies.md  
> **Purpose:** Understand IAM tags, policy structure, evaluation logic, and AWS best practices.

---

## 🧩 1. Overview

**IAM Policies** define what actions are **allowed or denied** for AWS identities (users, groups, or roles).  
**Tags** are metadata key-value pairs used to **organize, filter, or control access** to AWS resources.

| Concept | Description |
|----------|--------------|
| **Policy** | JSON document defining permissions |
| **Tag** | Key-value metadata used for management and access control |
| **Inline Policy** | Embedded directly in a user, group, or role |
| **Managed Policy** | Standalone reusable policy (AWS or customer-managed) |

---

## 📜 2. IAM Policy Structure

Each policy is a JSON document with the following structure:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "s3:ListBucket",
      "Resource": "arn:aws:s3:::my-bucket"
    }
  ]
}
```

| Element | Description |
|----------|--------------|
| **Version** | Policy language version (always use `2012-10-17`) |
| **Statement** | Array of one or more permissions |
| **Effect** | Allow or Deny |
| **Action** | API actions (e.g., `s3:GetObject`) |
| **Resource** | ARN of affected resource |
| **Condition** | Optional filters based on tags, time, IP, etc. |

---

## 🔐 3. Policy Types

| Type | Description | Example |
|------|--------------|----------|
| **AWS Managed Policy** | Predefined by AWS; maintained automatically | `AmazonS3ReadOnlyAccess` |
| **Customer Managed Policy** | Created and managed by your org | `CustomAppS3Policy` |
| **Inline Policy** | Attached directly to one entity | Developer group with embedded S3 access |

### 🧩 Example – Inline Policy
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "ec2:DescribeInstances",
      "Resource": "*"
    }
  ]
}
```

### 🧩 Example – Customer Managed Policy
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:PutItem",
        "dynamodb:GetItem"
      ],
      "Resource": "arn:aws:dynamodb:us-east-1:123456789012:table/AppData"
    }
  ]
}
```

---

## 🏷️ 4. IAM Tags

Tags provide **contextual metadata** for AWS identities and resources.

| Feature | Description |
|----------|--------------|
| **Key** | Tag name (e.g., `Environment`) |
| **Value** | Tag value (e.g., `Production`) |
| **Use Cases** | Cost allocation, automation, access control |

### 🧩 Example Tags
| Resource | Tag Key | Tag Value |
|-----------|----------|-----------|
| EC2 Instance | Environment | Dev |
| IAM User | Department | Finance |
| S3 Bucket | Project | DataLake |

---

## ⚙️ 5. Tag-Based Access Control

You can use **tags in IAM policies** for conditional access.

### 🧩 Example: Allow S3 Access Only for Matching Tags
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "s3:*",
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "aws:ResourceTag/Department": "${aws:PrincipalTag/Department}"
        }
      }
    }
  ]
}
```

✅ This ensures users can only access resources that share their **Department tag**.

---

## 🧮 6. Policy Evaluation Logic

AWS evaluates multiple policies using a **deny-by-default model**.

| Step | Evaluation Rule | Outcome |
|------|------------------|----------|
| 1 | By default, all requests are **denied** | ❌ Deny |
| 2 | If any policy **explicitly allows** → proceed | ✅ Allow |
| 3 | If any policy **explicitly denies** → override | ❌ Deny |
| 4 | Evaluate conditions (e.g., tags, MFA) | Conditional |
| 5 | Final result = **Allow** only if no explicit Deny exists | ✅ Allow |

### ⚖️ Evaluation Flow Example

```
Default Deny → Explicit Allow → Explicit Deny (overrides) → Final Decision
```

🧠 **Tip:** Always check for **explicit denies** in SCPs or IAM policies when troubleshooting access issues.

---

## 💡 7. Best Practices

| Best Practice | Description |
|----------------|-------------|
| **Use Managed Policies** | Easier to maintain and reuse |
| **Limit Inline Policies** | Avoid policy sprawl; use for special cases only |
| **Use Conditions and Tags** | Enforce fine-grained access control |
| **Enable IAM Access Analyzer** | Detect unused or overly broad permissions |
| **Follow Least Privilege Principle** | Grant only necessary actions on specific resources |
| **Tag Consistently** | Use naming conventions for automation & cost allocation |

---

## 🧠 8. Real-World Example

A company uses:
- Tags like `Environment=Prod` and `Department=Finance`  
- Conditional IAM policies that allow only users from `Finance` to access finance-related resources  
- AWS Cost Explorer filters based on tags for chargeback reports

This achieves **cost transparency** and **secure, tag-aware permissions**.

---

## 🎯 9. Certification Q&A

**Q1.** What’s the main difference between managed and inline policies?  
**A:** Managed policies are reusable and standalone; inline policies are embedded in one identity.

**Q2.** What happens if a request is both allowed and explicitly denied?  
**A:** ❌ The explicit deny always overrides.

**Q3.** Can IAM tags control access to resources?  
**A:** ✅ Yes, using condition keys like `aws:ResourceTag` and `aws:PrincipalTag`.

**Q4.** What’s the default behavior when no policy applies?  
**A:** ❌ Implicit Deny (default deny).

---

## 🏁 10. Key Takeaways

- **IAM Policies** control actions via JSON documents.  
- **Tags** enhance visibility, automation, and conditional access.  
- **Deny-by-default** model ensures secure evaluation.  
- Use **tags for cost allocation** and **policy conditions** for dynamic access control.  
- Combine IAM policies with **SCPs and resource policies** for full governance.

---

🏷️ *End of Document*  
**File:** `IAM_Tags_and_Policies.md`
